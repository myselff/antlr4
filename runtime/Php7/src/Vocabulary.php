<?php

/*
 * Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
namespace Antlr\V4\Runtime;



/**
 * This class provides a default implementation of the {@link Vocabulary}
 * interface.
 *
 * @author Sam Harwell
 */
class Vocabulary implements VocabularyInterface
{
    const EMPTY_NAMES = [];

    /**
     * Gets an empty {@link Vocabulary} instance.
     *
     * <p>
     * No literal or symbol names are assigned to token types, so
     * {@link #getDisplayName(int)} returns the numeric value for all tokens
     * except {@link Token#EOF}.</p>
     */
    //public static final VocabularyImpl EMPTY_VOCABULARY = new VocabularyImpl(EMPTY_NAMES, EMPTY_NAMES, EMPTY_NAMES);


    private $literalNames = [];

    private $symbolicNames = [];

    private $displayNames = [];

    private $maxTokenType;

    /**
     * Constructs a new instance of {@link VocabularyImpl} from the specified
     * literal, symbolic, and display token names.
     *
     * @param literalNames The literal names assigned to tokens, or {@code null}
     * if no literal names are assigned.
     * @param symbolicNames The symbolic names assigned to tokens, or
     * {@code null} if no symbolic names are assigned.
     * @param displayNames The display names assigned to tokens, or {@code null}
     * to use the values in {@code literalNames} and {@code symbolicNames} as
     * the source of display names, as described in
     * {@link #getDisplayName(int)}.
     *
     * @see #getLiteralName(int)
     * @see #getSymbolicName(int)
     * @see #getDisplayName(int)
     */
    public function __construct(array $literalNames = null, array $symbolicNames = null, array $displayNames = [])
    {
        $this->literalNames = $literalNames != null ? $literalNames : self::EMPTY_NAMES;
        $this->symbolicNames = $symbolicNames != null ? $symbolicNames : self::EMPTY_NAMES;
        $this->displayNames = $displayNames != null ? $displayNames : self::EMPTY_NAMES;
        // See note here on -1 part: https://github.com/antlr/antlr4/pull/1146
        $this->maxTokenType =
            max(count($this->displayNames),
                max(count($this->literalNames), count($this->symbolicNames))) - 1;
    }



	/**
     * Returns a {@link VocabularyImpl} instance from the specified set of token
     * names. This method acts as a compatibility layer for the single
     * {@code tokenNames} array generated by previous releases of ANTLR.
     *
     * <p>The resulting vocabulary instance returns {@code null} for
     * {@link #getLiteralName(int)} and {@link #getSymbolicName(int)}, and the
     * value from {@code tokenNames} for the display names.</p>
     *
     * @param tokenNames The token names, or {@code null} if no token names are
     * available.
     * @return A {@link Vocabulary} instance which uses {@code tokenNames} for
     * the display names of tokens.
     */
	public static function fromTokenNames(array $tokenNames): Vocabulary
    {
        if ($tokenNames == null || count($tokenNames) == 0) {
            return new self();
        }

        $literalNames = array_slice($tokenNames, 0, count($tokenNames));
		$symbolicNames = array_slice($tokenNames, 0, count($tokenNames));
		for ($i = 0; $i < count($tokenNames); $i++) {
            $tokenName = $tokenNames[$i];
			if ($tokenName == null) {
                continue;
            }

			if (!empty($tokenName)) {
                $firstChar = $tokenName[0];
				if ($firstChar == '\'') {
                    $symbolicNames[$i] = null;
                    continue;
                }
                else if (ctype_upper($firstChar)) {
                    $literalNames[$i] = null;
                    continue;
                }
			}

			// wasn't a literal or symbolic name
			$literalNames[$i] = null;
			$symbolicNames[$i] = null;
		}

		return new self($literalNames, $symbolicNames, $tokenNames);
	}


	public function getMaxTokenType(): int
    {
		return $this->maxTokenType;
	}

	public function getLiteralName(int $tokenType): string
    {
        if ($tokenType >= 0 && $tokenType < count($this->literalNames)) {
            return $this->literalNames[$tokenType];
        }

        return null;
    }

	public function getSymbolicName(int $tokenType): string
    {
        if ($tokenType >= 0 && $tokenType < count($this->symbolicNames)) {
            return $this->symbolicNames[$tokenType];
        }

        if ($tokenType == TokenInterface::EOF) {
            return "EOF";
        }

        return null;
    }

	public function getDisplayName(int $tokenType): string
    {
        if ($tokenType >= 0 && $tokenType < count($this->displayNames)) {
            $displayName = $this->displayNames[$tokenType];
			if ($displayName != null) {
                return $displayName;
            }
		}

        $literalName = $this->getLiteralName($tokenType);
		if ($literalName != null) {
            return $literalName;
        }

		$symbolicName = $this->getSymbolicName($tokenType);
		if ($symbolicName != null) {
            return $symbolicName;
        }

		return (string)$tokenType;
	}
}
